// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: rook/matchmaker/tx.proto

package types

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	grpc1 "github.com/gogo/protobuf/grpc"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MsgHost struct {
	// The host of the room
	Host string `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
	// Types that are valid to be assigned to Game:
	//	*MsgHost_Mode
	//	*MsgHost_ModeId
	Game isMsgHost_Game `protobuf_oneof:"game"`
	// the list of players that are invited to join the room
	Invitees []string `protobuf:"bytes,4,rep,name=invitees,proto3" json:"invitees,omitempty"`
	// public defines whether the room is open for all players to join
	Public bool `protobuf:"varint,5,opt,name=public,proto3" json:"public,omitempty"`
	// For scheduled games (like tournaments). Participants have until
	// then to join. The game only starts if the quorum is met.
	Scheduled *time.Time `protobuf:"bytes,6,opt,name=scheduled,proto3,stdtime" json:"scheduled,omitempty"`
}

func (m *MsgHost) Reset()         { *m = MsgHost{} }
func (m *MsgHost) String() string { return proto.CompactTextString(m) }
func (*MsgHost) ProtoMessage()    {}
func (*MsgHost) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a341be17b67dd1e, []int{0}
}
func (m *MsgHost) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgHost) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgHost.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgHost) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgHost.Merge(m, src)
}
func (m *MsgHost) XXX_Size() int {
	return m.Size()
}
func (m *MsgHost) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgHost.DiscardUnknown(m)
}

var xxx_messageInfo_MsgHost proto.InternalMessageInfo

type isMsgHost_Game interface {
	isMsgHost_Game()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MsgHost_Mode struct {
	Mode *Mode `protobuf:"bytes,2,opt,name=mode,proto3,oneof" json:"mode,omitempty"`
}
type MsgHost_ModeId struct {
	ModeId uint32 `protobuf:"varint,3,opt,name=mode_id,json=modeId,proto3,oneof" json:"mode_id,omitempty"`
}

func (*MsgHost_Mode) isMsgHost_Game()   {}
func (*MsgHost_ModeId) isMsgHost_Game() {}

func (m *MsgHost) GetGame() isMsgHost_Game {
	if m != nil {
		return m.Game
	}
	return nil
}

func (m *MsgHost) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *MsgHost) GetMode() *Mode {
	if x, ok := m.GetGame().(*MsgHost_Mode); ok {
		return x.Mode
	}
	return nil
}

func (m *MsgHost) GetModeId() uint32 {
	if x, ok := m.GetGame().(*MsgHost_ModeId); ok {
		return x.ModeId
	}
	return 0
}

func (m *MsgHost) GetInvitees() []string {
	if m != nil {
		return m.Invitees
	}
	return nil
}

func (m *MsgHost) GetPublic() bool {
	if m != nil {
		return m.Public
	}
	return false
}

func (m *MsgHost) GetScheduled() *time.Time {
	if m != nil {
		return m.Scheduled
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MsgHost) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MsgHost_Mode)(nil),
		(*MsgHost_ModeId)(nil),
	}
}

type MsgHostResponse struct {
	RoomId uint64 `protobuf:"varint,1,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty"`
}

func (m *MsgHostResponse) Reset()         { *m = MsgHostResponse{} }
func (m *MsgHostResponse) String() string { return proto.CompactTextString(m) }
func (*MsgHostResponse) ProtoMessage()    {}
func (*MsgHostResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a341be17b67dd1e, []int{1}
}
func (m *MsgHostResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgHostResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgHostResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgHostResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgHostResponse.Merge(m, src)
}
func (m *MsgHostResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgHostResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgHostResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgHostResponse proto.InternalMessageInfo

func (m *MsgHostResponse) GetRoomId() uint64 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

type MsgJoin struct {
	Player string `protobuf:"bytes,1,opt,name=player,proto3" json:"player,omitempty"`
	RoomId uint64 `protobuf:"varint,2,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty"`
}

func (m *MsgJoin) Reset()         { *m = MsgJoin{} }
func (m *MsgJoin) String() string { return proto.CompactTextString(m) }
func (*MsgJoin) ProtoMessage()    {}
func (*MsgJoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a341be17b67dd1e, []int{2}
}
func (m *MsgJoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgJoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgJoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgJoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgJoin.Merge(m, src)
}
func (m *MsgJoin) XXX_Size() int {
	return m.Size()
}
func (m *MsgJoin) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgJoin.DiscardUnknown(m)
}

var xxx_messageInfo_MsgJoin proto.InternalMessageInfo

func (m *MsgJoin) GetPlayer() string {
	if m != nil {
		return m.Player
	}
	return ""
}

func (m *MsgJoin) GetRoomId() uint64 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

type MsgJoinResponse struct {
}

func (m *MsgJoinResponse) Reset()         { *m = MsgJoinResponse{} }
func (m *MsgJoinResponse) String() string { return proto.CompactTextString(m) }
func (*MsgJoinResponse) ProtoMessage()    {}
func (*MsgJoinResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a341be17b67dd1e, []int{3}
}
func (m *MsgJoinResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgJoinResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgJoinResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgJoinResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgJoinResponse.Merge(m, src)
}
func (m *MsgJoinResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgJoinResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgJoinResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgJoinResponse proto.InternalMessageInfo

type MsgFind struct {
	Player string `protobuf:"bytes,1,opt,name=player,proto3" json:"player,omitempty"`
	Mode   uint32 `protobuf:"varint,2,opt,name=mode,proto3" json:"mode,omitempty"`
}

func (m *MsgFind) Reset()         { *m = MsgFind{} }
func (m *MsgFind) String() string { return proto.CompactTextString(m) }
func (*MsgFind) ProtoMessage()    {}
func (*MsgFind) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a341be17b67dd1e, []int{4}
}
func (m *MsgFind) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgFind) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgFind.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgFind) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgFind.Merge(m, src)
}
func (m *MsgFind) XXX_Size() int {
	return m.Size()
}
func (m *MsgFind) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgFind.DiscardUnknown(m)
}

var xxx_messageInfo_MsgFind proto.InternalMessageInfo

func (m *MsgFind) GetPlayer() string {
	if m != nil {
		return m.Player
	}
	return ""
}

func (m *MsgFind) GetMode() uint32 {
	if m != nil {
		return m.Mode
	}
	return 0
}

type MsgFindResponse struct {
	RoomId uint64 `protobuf:"varint,1,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty"`
}

func (m *MsgFindResponse) Reset()         { *m = MsgFindResponse{} }
func (m *MsgFindResponse) String() string { return proto.CompactTextString(m) }
func (*MsgFindResponse) ProtoMessage()    {}
func (*MsgFindResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a341be17b67dd1e, []int{5}
}
func (m *MsgFindResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgFindResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgFindResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgFindResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgFindResponse.Merge(m, src)
}
func (m *MsgFindResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgFindResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgFindResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgFindResponse proto.InternalMessageInfo

func (m *MsgFindResponse) GetRoomId() uint64 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

type MsgLeave struct {
	Player string `protobuf:"bytes,1,opt,name=player,proto3" json:"player,omitempty"`
	RoomId uint64 `protobuf:"varint,2,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty"`
}

func (m *MsgLeave) Reset()         { *m = MsgLeave{} }
func (m *MsgLeave) String() string { return proto.CompactTextString(m) }
func (*MsgLeave) ProtoMessage()    {}
func (*MsgLeave) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a341be17b67dd1e, []int{6}
}
func (m *MsgLeave) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgLeave) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgLeave.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgLeave) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgLeave.Merge(m, src)
}
func (m *MsgLeave) XXX_Size() int {
	return m.Size()
}
func (m *MsgLeave) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgLeave.DiscardUnknown(m)
}

var xxx_messageInfo_MsgLeave proto.InternalMessageInfo

func (m *MsgLeave) GetPlayer() string {
	if m != nil {
		return m.Player
	}
	return ""
}

func (m *MsgLeave) GetRoomId() uint64 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

type MsgLeaveResponse struct {
}

func (m *MsgLeaveResponse) Reset()         { *m = MsgLeaveResponse{} }
func (m *MsgLeaveResponse) String() string { return proto.CompactTextString(m) }
func (*MsgLeaveResponse) ProtoMessage()    {}
func (*MsgLeaveResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a341be17b67dd1e, []int{7}
}
func (m *MsgLeaveResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgLeaveResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgLeaveResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgLeaveResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgLeaveResponse.Merge(m, src)
}
func (m *MsgLeaveResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgLeaveResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgLeaveResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgLeaveResponse proto.InternalMessageInfo

type MsgAddMode struct {
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	Mode      Mode   `protobuf:"bytes,2,opt,name=mode,proto3" json:"mode"`
}

func (m *MsgAddMode) Reset()         { *m = MsgAddMode{} }
func (m *MsgAddMode) String() string { return proto.CompactTextString(m) }
func (*MsgAddMode) ProtoMessage()    {}
func (*MsgAddMode) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a341be17b67dd1e, []int{8}
}
func (m *MsgAddMode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddMode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddMode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddMode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddMode.Merge(m, src)
}
func (m *MsgAddMode) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddMode) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddMode.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddMode proto.InternalMessageInfo

func (m *MsgAddMode) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgAddMode) GetMode() Mode {
	if m != nil {
		return m.Mode
	}
	return Mode{}
}

type MsgAddModeResponse struct {
	ModeId uint32 `protobuf:"varint,1,opt,name=mode_id,json=modeId,proto3" json:"mode_id,omitempty"`
}

func (m *MsgAddModeResponse) Reset()         { *m = MsgAddModeResponse{} }
func (m *MsgAddModeResponse) String() string { return proto.CompactTextString(m) }
func (*MsgAddModeResponse) ProtoMessage()    {}
func (*MsgAddModeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a341be17b67dd1e, []int{9}
}
func (m *MsgAddModeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddModeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddModeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddModeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddModeResponse.Merge(m, src)
}
func (m *MsgAddModeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddModeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddModeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddModeResponse proto.InternalMessageInfo

func (m *MsgAddModeResponse) GetModeId() uint32 {
	if m != nil {
		return m.ModeId
	}
	return 0
}

type MsgRemoveMode struct {
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	Id        uint32 `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *MsgRemoveMode) Reset()         { *m = MsgRemoveMode{} }
func (m *MsgRemoveMode) String() string { return proto.CompactTextString(m) }
func (*MsgRemoveMode) ProtoMessage()    {}
func (*MsgRemoveMode) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a341be17b67dd1e, []int{10}
}
func (m *MsgRemoveMode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRemoveMode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRemoveMode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRemoveMode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRemoveMode.Merge(m, src)
}
func (m *MsgRemoveMode) XXX_Size() int {
	return m.Size()
}
func (m *MsgRemoveMode) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRemoveMode.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRemoveMode proto.InternalMessageInfo

func (m *MsgRemoveMode) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgRemoveMode) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

type MsgRemoveModeResponse struct {
}

func (m *MsgRemoveModeResponse) Reset()         { *m = MsgRemoveModeResponse{} }
func (m *MsgRemoveModeResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRemoveModeResponse) ProtoMessage()    {}
func (*MsgRemoveModeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a341be17b67dd1e, []int{11}
}
func (m *MsgRemoveModeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRemoveModeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRemoveModeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRemoveModeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRemoveModeResponse.Merge(m, src)
}
func (m *MsgRemoveModeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRemoveModeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRemoveModeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRemoveModeResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MsgHost)(nil), "rook.matchmaker.MsgHost")
	proto.RegisterType((*MsgHostResponse)(nil), "rook.matchmaker.MsgHostResponse")
	proto.RegisterType((*MsgJoin)(nil), "rook.matchmaker.MsgJoin")
	proto.RegisterType((*MsgJoinResponse)(nil), "rook.matchmaker.MsgJoinResponse")
	proto.RegisterType((*MsgFind)(nil), "rook.matchmaker.MsgFind")
	proto.RegisterType((*MsgFindResponse)(nil), "rook.matchmaker.MsgFindResponse")
	proto.RegisterType((*MsgLeave)(nil), "rook.matchmaker.MsgLeave")
	proto.RegisterType((*MsgLeaveResponse)(nil), "rook.matchmaker.MsgLeaveResponse")
	proto.RegisterType((*MsgAddMode)(nil), "rook.matchmaker.MsgAddMode")
	proto.RegisterType((*MsgAddModeResponse)(nil), "rook.matchmaker.MsgAddModeResponse")
	proto.RegisterType((*MsgRemoveMode)(nil), "rook.matchmaker.MsgRemoveMode")
	proto.RegisterType((*MsgRemoveModeResponse)(nil), "rook.matchmaker.MsgRemoveModeResponse")
}

func init() { proto.RegisterFile("rook/matchmaker/tx.proto", fileDescriptor_2a341be17b67dd1e) }

var fileDescriptor_2a341be17b67dd1e = []byte{
	// 603 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xcd, 0x6e, 0xd3, 0x40,
	0x18, 0x8c, 0x13, 0xd7, 0x69, 0x3e, 0x14, 0x0a, 0x2b, 0x4a, 0x5d, 0x83, 0x1c, 0x63, 0x24, 0x14,
	0x81, 0x6a, 0x4b, 0x45, 0x5c, 0x40, 0x20, 0x61, 0x09, 0x94, 0x00, 0xbe, 0x58, 0x3d, 0xc1, 0x01,
	0x39, 0xf1, 0xe2, 0x58, 0x89, 0xb3, 0x91, 0x77, 0x13, 0x9a, 0xb7, 0xe8, 0xfb, 0xf0, 0x02, 0x3d,
	0xf6, 0xc8, 0x89, 0x9f, 0xe4, 0x45, 0xd0, 0xae, 0xed, 0x38, 0x29, 0x4e, 0x29, 0x27, 0xef, 0xb7,
	0xb3, 0x33, 0x3b, 0xdf, 0xb7, 0x23, 0x83, 0x9a, 0x10, 0x32, 0xb4, 0x63, 0x9f, 0xf5, 0x07, 0xb1,
	0x3f, 0xc4, 0x89, 0xcd, 0x4e, 0xad, 0x49, 0x42, 0x18, 0x41, 0x7b, 0x1c, 0xb1, 0x0a, 0x44, 0x33,
	0x2e, 0x1f, 0x2d, 0x96, 0x29, 0x45, 0xbb, 0x13, 0x92, 0x90, 0x88, 0xa5, 0xcd, 0x57, 0xd9, 0x6e,
	0x2b, 0x24, 0x24, 0x1c, 0x61, 0x5b, 0x54, 0xbd, 0xe9, 0x17, 0x9b, 0x45, 0x31, 0xa6, 0xcc, 0x8f,
	0x27, 0xe9, 0x01, 0xf3, 0xb7, 0x04, 0x75, 0x97, 0x86, 0x1d, 0x42, 0x19, 0x42, 0x20, 0x0f, 0x08,
	0x65, 0xaa, 0x64, 0x48, 0xed, 0x86, 0x27, 0xd6, 0xe8, 0x09, 0xc8, 0x31, 0x09, 0xb0, 0x5a, 0x35,
	0xa4, 0xf6, 0x8d, 0xe3, 0x7d, 0xeb, 0x92, 0x31, 0xcb, 0x25, 0x01, 0xee, 0x54, 0x3c, 0x71, 0x08,
	0x1d, 0x42, 0x9d, 0x7f, 0x3f, 0x47, 0x81, 0x5a, 0x33, 0xa4, 0x76, 0xb3, 0x53, 0xf1, 0x14, 0xbe,
	0xd1, 0x0d, 0x90, 0x06, 0xbb, 0xd1, 0x78, 0x16, 0x31, 0x8c, 0xa9, 0x2a, 0x1b, 0xb5, 0x76, 0xc3,
	0x5b, 0xd5, 0xe8, 0x2e, 0x28, 0x93, 0x69, 0x6f, 0x14, 0xf5, 0xd5, 0x1d, 0x43, 0x6a, 0xef, 0x7a,
	0x59, 0x85, 0x5e, 0x41, 0x83, 0xf6, 0x07, 0x38, 0x98, 0x8e, 0x70, 0xa0, 0x2a, 0xc2, 0x80, 0x66,
	0xa5, 0x0d, 0x59, 0x79, 0x43, 0xd6, 0x49, 0xde, 0x90, 0x23, 0x9f, 0xfd, 0x6c, 0x49, 0x5e, 0x41,
	0x71, 0x14, 0x90, 0x43, 0x3f, 0xc6, 0xe6, 0x63, 0xd8, 0xcb, 0x5a, 0xf4, 0x30, 0x9d, 0x90, 0x31,
	0xc5, 0xe8, 0x00, 0xea, 0x09, 0x21, 0x31, 0x77, 0xca, 0xbb, 0x95, 0x3d, 0x85, 0x97, 0xdd, 0xc0,
	0x7c, 0x2e, 0xc6, 0xf1, 0x8e, 0x44, 0x63, 0x61, 0x6b, 0xe4, 0xcf, 0x71, 0x92, 0x0d, 0x24, 0xab,
	0xd6, 0xb9, 0xd5, 0x0d, 0xee, 0x6d, 0x71, 0x0f, 0xe7, 0xe6, 0xf7, 0x98, 0xcf, 0x84, 0xdc, 0xdb,
	0x68, 0x1c, 0x6c, 0x95, 0x43, 0x6b, 0x13, 0x6e, 0xa6, 0x83, 0xcc, 0x1c, 0x73, 0xda, 0xbf, 0x1d,
	0xbf, 0x80, 0x5d, 0x97, 0x86, 0x1f, 0xb0, 0x3f, 0xc3, 0xff, 0x6f, 0x19, 0xc1, 0xad, 0x9c, 0xbc,
	0xf2, 0xfc, 0x09, 0xc0, 0xa5, 0xe1, 0xeb, 0x20, 0xe0, 0x6f, 0x8b, 0xee, 0x43, 0xc3, 0x9f, 0xb2,
	0x01, 0x49, 0x22, 0x36, 0xcf, 0x54, 0x8b, 0x0d, 0x64, 0x5f, 0x23, 0x1e, 0x8e, 0x7c, 0xfe, 0xa3,
	0x95, 0x45, 0xc4, 0x3c, 0x02, 0x54, 0x88, 0xaf, 0x37, 0x97, 0x07, 0x47, 0x12, 0x63, 0xc8, 0x62,
	0x63, 0xbe, 0x84, 0xa6, 0x4b, 0x43, 0x0f, 0xc7, 0x64, 0x86, 0xaf, 0x61, 0xe7, 0x26, 0x54, 0xb3,
	0x16, 0x9b, 0x5e, 0x35, 0x0a, 0xcc, 0x03, 0xd8, 0xdf, 0xa0, 0xe7, 0x17, 0x1e, 0x7f, 0xab, 0x41,
	0xcd, 0xa5, 0x21, 0x72, 0x40, 0x16, 0xd1, 0x57, 0xff, 0x76, 0x9e, 0x26, 0x46, 0x33, 0xb6, 0x21,
	0x2b, 0xf3, 0x0e, 0xc8, 0x22, 0x2f, 0xa5, 0x1a, 0x1c, 0x29, 0xd7, 0x58, 0xcf, 0x09, 0xd7, 0x10,
	0x21, 0x29, 0xd5, 0xe0, 0x48, 0xb9, 0xc6, 0x46, 0x42, 0xde, 0xc0, 0x4e, 0x9a, 0x82, 0xc3, 0xb2,
	0xa3, 0x02, 0xd2, 0x1e, 0x6c, 0x85, 0x56, 0x32, 0xef, 0xa1, 0x9e, 0xbf, 0xfd, 0xbd, 0xb2, 0xd3,
	0x19, 0xa8, 0x3d, 0xbc, 0x02, 0x5c, 0x89, 0x9d, 0x00, 0xac, 0x3d, 0x9e, 0x5e, 0x46, 0x29, 0x70,
	0xed, 0xd1, 0xd5, 0x78, 0xae, 0xea, 0x74, 0xcf, 0x17, 0xba, 0x74, 0xb1, 0xd0, 0xa5, 0x5f, 0x0b,
	0x5d, 0x3a, 0x5b, 0xea, 0x95, 0x8b, 0xa5, 0x5e, 0xf9, 0xbe, 0xd4, 0x2b, 0x1f, 0xed, 0x30, 0x62,
	0x83, 0x69, 0xcf, 0xea, 0x93, 0xd8, 0xe6, 0x5a, 0x47, 0x63, 0xcc, 0xbe, 0x92, 0x64, 0x28, 0x0a,
	0xfb, 0x74, 0xe3, 0x67, 0x3b, 0x9f, 0x60, 0xda, 0x53, 0xc4, 0x8f, 0xe4, 0xe9, 0x9f, 0x00, 0x00,
	0x00, 0xff, 0xff, 0xa6, 0xd8, 0x91, 0x93, 0x8c, 0x05, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// Host creates a room for a custom game
	Host(ctx context.Context, in *MsgHost, opts ...grpc.CallOption) (*MsgHostResponse, error)
	// Join adds a player to a room
	Join(ctx context.Context, in *MsgJoin, opts ...grpc.CallOption) (*MsgJoinResponse, error)
	// Find adds a player to a room based of a mode
	Find(ctx context.Context, in *MsgFind, opts ...grpc.CallOption) (*MsgFindResponse, error)
	// Leave removes a player from the room they are in.
	Leave(ctx context.Context, in *MsgLeave, opts ...grpc.CallOption) (*MsgLeaveResponse, error)
	// AddMode adds a new mode
	AddMode(ctx context.Context, in *MsgAddMode, opts ...grpc.CallOption) (*MsgAddModeResponse, error)
	// RemoveMode removes an existing mode
	RemoveMode(ctx context.Context, in *MsgRemoveMode, opts ...grpc.CallOption) (*MsgRemoveModeResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) Host(ctx context.Context, in *MsgHost, opts ...grpc.CallOption) (*MsgHostResponse, error) {
	out := new(MsgHostResponse)
	err := c.cc.Invoke(ctx, "/rook.matchmaker.Msg/Host", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Join(ctx context.Context, in *MsgJoin, opts ...grpc.CallOption) (*MsgJoinResponse, error) {
	out := new(MsgJoinResponse)
	err := c.cc.Invoke(ctx, "/rook.matchmaker.Msg/Join", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Find(ctx context.Context, in *MsgFind, opts ...grpc.CallOption) (*MsgFindResponse, error) {
	out := new(MsgFindResponse)
	err := c.cc.Invoke(ctx, "/rook.matchmaker.Msg/Find", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Leave(ctx context.Context, in *MsgLeave, opts ...grpc.CallOption) (*MsgLeaveResponse, error) {
	out := new(MsgLeaveResponse)
	err := c.cc.Invoke(ctx, "/rook.matchmaker.Msg/Leave", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AddMode(ctx context.Context, in *MsgAddMode, opts ...grpc.CallOption) (*MsgAddModeResponse, error) {
	out := new(MsgAddModeResponse)
	err := c.cc.Invoke(ctx, "/rook.matchmaker.Msg/AddMode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RemoveMode(ctx context.Context, in *MsgRemoveMode, opts ...grpc.CallOption) (*MsgRemoveModeResponse, error) {
	out := new(MsgRemoveModeResponse)
	err := c.cc.Invoke(ctx, "/rook.matchmaker.Msg/RemoveMode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// Host creates a room for a custom game
	Host(context.Context, *MsgHost) (*MsgHostResponse, error)
	// Join adds a player to a room
	Join(context.Context, *MsgJoin) (*MsgJoinResponse, error)
	// Find adds a player to a room based of a mode
	Find(context.Context, *MsgFind) (*MsgFindResponse, error)
	// Leave removes a player from the room they are in.
	Leave(context.Context, *MsgLeave) (*MsgLeaveResponse, error)
	// AddMode adds a new mode
	AddMode(context.Context, *MsgAddMode) (*MsgAddModeResponse, error)
	// RemoveMode removes an existing mode
	RemoveMode(context.Context, *MsgRemoveMode) (*MsgRemoveModeResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) Host(ctx context.Context, req *MsgHost) (*MsgHostResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Host not implemented")
}
func (*UnimplementedMsgServer) Join(ctx context.Context, req *MsgJoin) (*MsgJoinResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Join not implemented")
}
func (*UnimplementedMsgServer) Find(ctx context.Context, req *MsgFind) (*MsgFindResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Find not implemented")
}
func (*UnimplementedMsgServer) Leave(ctx context.Context, req *MsgLeave) (*MsgLeaveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Leave not implemented")
}
func (*UnimplementedMsgServer) AddMode(ctx context.Context, req *MsgAddMode) (*MsgAddModeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddMode not implemented")
}
func (*UnimplementedMsgServer) RemoveMode(ctx context.Context, req *MsgRemoveMode) (*MsgRemoveModeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveMode not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_Host_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgHost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Host(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rook.matchmaker.Msg/Host",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Host(ctx, req.(*MsgHost))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Join_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgJoin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Join(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rook.matchmaker.Msg/Join",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Join(ctx, req.(*MsgJoin))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgFind)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rook.matchmaker.Msg/Find",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Find(ctx, req.(*MsgFind))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Leave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgLeave)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Leave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rook.matchmaker.Msg/Leave",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Leave(ctx, req.(*MsgLeave))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AddMode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAddMode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AddMode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rook.matchmaker.Msg/AddMode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AddMode(ctx, req.(*MsgAddMode))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RemoveMode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRemoveMode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RemoveMode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rook.matchmaker.Msg/RemoveMode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RemoveMode(ctx, req.(*MsgRemoveMode))
	}
	return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "rook.matchmaker.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Host",
			Handler:    _Msg_Host_Handler,
		},
		{
			MethodName: "Join",
			Handler:    _Msg_Join_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _Msg_Find_Handler,
		},
		{
			MethodName: "Leave",
			Handler:    _Msg_Leave_Handler,
		},
		{
			MethodName: "AddMode",
			Handler:    _Msg_AddMode_Handler,
		},
		{
			MethodName: "RemoveMode",
			Handler:    _Msg_RemoveMode_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rook/matchmaker/tx.proto",
}

func (m *MsgHost) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgHost) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgHost) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Scheduled != nil {
		n1, err1 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.Scheduled, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.Scheduled):])
		if err1 != nil {
			return 0, err1
		}
		i -= n1
		i = encodeVarintTx(dAtA, i, uint64(n1))
		i--
		dAtA[i] = 0x32
	}
	if m.Public {
		i--
		if m.Public {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Invitees) > 0 {
		for iNdEx := len(m.Invitees) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Invitees[iNdEx])
			copy(dAtA[i:], m.Invitees[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.Invitees[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Game != nil {
		{
			size := m.Game.Size()
			i -= size
			if _, err := m.Game.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Host) > 0 {
		i -= len(m.Host)
		copy(dAtA[i:], m.Host)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Host)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgHost_Mode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgHost_Mode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Mode != nil {
		{
			size, err := m.Mode.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *MsgHost_ModeId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgHost_ModeId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTx(dAtA, i, uint64(m.ModeId))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *MsgHostResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgHostResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgHostResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RoomId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.RoomId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgJoin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgJoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgJoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RoomId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.RoomId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Player) > 0 {
		i -= len(m.Player)
		copy(dAtA[i:], m.Player)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Player)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgJoinResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgJoinResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgJoinResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgFind) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgFind) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgFind) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Mode != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Player) > 0 {
		i -= len(m.Player)
		copy(dAtA[i:], m.Player)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Player)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgFindResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgFindResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgFindResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RoomId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.RoomId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgLeave) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgLeave) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgLeave) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RoomId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.RoomId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Player) > 0 {
		i -= len(m.Player)
		copy(dAtA[i:], m.Player)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Player)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgLeaveResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgLeaveResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgLeaveResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgAddMode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddMode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddMode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Mode.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAddModeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddModeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddModeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ModeId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ModeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgRemoveMode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRemoveMode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRemoveMode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRemoveModeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRemoveModeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRemoveModeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgHost) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Game != nil {
		n += m.Game.Size()
	}
	if len(m.Invitees) > 0 {
		for _, s := range m.Invitees {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.Public {
		n += 2
	}
	if m.Scheduled != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.Scheduled)
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgHost_Mode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mode != nil {
		l = m.Mode.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}
func (m *MsgHost_ModeId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTx(uint64(m.ModeId))
	return n
}
func (m *MsgHostResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoomId != 0 {
		n += 1 + sovTx(uint64(m.RoomId))
	}
	return n
}

func (m *MsgJoin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Player)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.RoomId != 0 {
		n += 1 + sovTx(uint64(m.RoomId))
	}
	return n
}

func (m *MsgJoinResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgFind) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Player)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Mode != 0 {
		n += 1 + sovTx(uint64(m.Mode))
	}
	return n
}

func (m *MsgFindResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoomId != 0 {
		n += 1 + sovTx(uint64(m.RoomId))
	}
	return n
}

func (m *MsgLeave) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Player)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.RoomId != 0 {
		n += 1 + sovTx(uint64(m.RoomId))
	}
	return n
}

func (m *MsgLeaveResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgAddMode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Mode.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgAddModeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ModeId != 0 {
		n += 1 + sovTx(uint64(m.ModeId))
	}
	return n
}

func (m *MsgRemoveMode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovTx(uint64(m.Id))
	}
	return n
}

func (m *MsgRemoveModeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgHost) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgHost: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgHost: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Mode{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Game = &MsgHost_Mode{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModeId", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Game = &MsgHost_ModeId{v}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invitees", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Invitees = append(m.Invitees, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Public", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Public = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheduled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Scheduled == nil {
				m.Scheduled = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.Scheduled, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgHostResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgHostResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgHostResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgJoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgJoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgJoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Player", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Player = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgJoinResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgJoinResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgJoinResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgFind) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgFind: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgFind: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Player", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Player = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgFindResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgFindResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgFindResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgLeave) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgLeave: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgLeave: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Player", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Player = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgLeaveResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgLeaveResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgLeaveResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddMode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddMode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddMode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Mode.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddModeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddModeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddModeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModeId", wireType)
			}
			m.ModeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModeId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRemoveMode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRemoveMode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRemoveMode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRemoveModeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRemoveModeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRemoveModeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
